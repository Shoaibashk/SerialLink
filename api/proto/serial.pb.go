// Copyright 2024 BaudLink Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        (unknown)
// source: serial.proto

package serialpb

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type PortType int32

const (
	PortType_PORT_TYPE_UNSPECIFIED PortType = 0
	PortType_PORT_TYPE_USB         PortType = 1
	PortType_PORT_TYPE_NATIVE      PortType = 2
	PortType_PORT_TYPE_BLUETOOTH   PortType = 3
	PortType_PORT_TYPE_VIRTUAL     PortType = 4
)

// Enum value maps for PortType.
var (
	PortType_name = map[int32]string{
		0: "PORT_TYPE_UNSPECIFIED",
		1: "PORT_TYPE_USB",
		2: "PORT_TYPE_NATIVE",
		3: "PORT_TYPE_BLUETOOTH",
		4: "PORT_TYPE_VIRTUAL",
	}
	PortType_value = map[string]int32{
		"PORT_TYPE_UNSPECIFIED": 0,
		"PORT_TYPE_USB":         1,
		"PORT_TYPE_NATIVE":      2,
		"PORT_TYPE_BLUETOOTH":   3,
		"PORT_TYPE_VIRTUAL":     4,
	}
)

func (x PortType) Enum() *PortType {
	p := new(PortType)
	*p = x
	return p
}

func (x PortType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PortType) Descriptor() protoreflect.EnumDescriptor {
	return file_serial_proto_enumTypes[0].Descriptor()
}

func (PortType) Type() protoreflect.EnumType {
	return &file_serial_proto_enumTypes[0]
}

func (x PortType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PortType.Descriptor instead.
func (PortType) EnumDescriptor() ([]byte, []int) {
	return file_serial_proto_rawDescGZIP(), []int{0}
}

type DataBits int32

const (
	DataBits_DATA_BITS_UNSPECIFIED DataBits = 0
	DataBits_DATA_BITS_5           DataBits = 5
	DataBits_DATA_BITS_6           DataBits = 6
	DataBits_DATA_BITS_7           DataBits = 7
	DataBits_DATA_BITS_8           DataBits = 8
)

// Enum value maps for DataBits.
var (
	DataBits_name = map[int32]string{
		0: "DATA_BITS_UNSPECIFIED",
		5: "DATA_BITS_5",
		6: "DATA_BITS_6",
		7: "DATA_BITS_7",
		8: "DATA_BITS_8",
	}
	DataBits_value = map[string]int32{
		"DATA_BITS_UNSPECIFIED": 0,
		"DATA_BITS_5":           5,
		"DATA_BITS_6":           6,
		"DATA_BITS_7":           7,
		"DATA_BITS_8":           8,
	}
)

func (x DataBits) Enum() *DataBits {
	p := new(DataBits)
	*p = x
	return p
}

func (x DataBits) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (DataBits) Descriptor() protoreflect.EnumDescriptor {
	return file_serial_proto_enumTypes[1].Descriptor()
}

func (DataBits) Type() protoreflect.EnumType {
	return &file_serial_proto_enumTypes[1]
}

func (x DataBits) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use DataBits.Descriptor instead.
func (DataBits) EnumDescriptor() ([]byte, []int) {
	return file_serial_proto_rawDescGZIP(), []int{1}
}

type StopBits int32

const (
	StopBits_STOP_BITS_UNSPECIFIED StopBits = 0
	StopBits_STOP_BITS_1           StopBits = 1
	StopBits_STOP_BITS_1_5         StopBits = 2
	StopBits_STOP_BITS_2           StopBits = 3
)

// Enum value maps for StopBits.
var (
	StopBits_name = map[int32]string{
		0: "STOP_BITS_UNSPECIFIED",
		1: "STOP_BITS_1",
		2: "STOP_BITS_1_5",
		3: "STOP_BITS_2",
	}
	StopBits_value = map[string]int32{
		"STOP_BITS_UNSPECIFIED": 0,
		"STOP_BITS_1":           1,
		"STOP_BITS_1_5":         2,
		"STOP_BITS_2":           3,
	}
)

func (x StopBits) Enum() *StopBits {
	p := new(StopBits)
	*p = x
	return p
}

func (x StopBits) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (StopBits) Descriptor() protoreflect.EnumDescriptor {
	return file_serial_proto_enumTypes[2].Descriptor()
}

func (StopBits) Type() protoreflect.EnumType {
	return &file_serial_proto_enumTypes[2]
}

func (x StopBits) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use StopBits.Descriptor instead.
func (StopBits) EnumDescriptor() ([]byte, []int) {
	return file_serial_proto_rawDescGZIP(), []int{2}
}

type Parity int32

const (
	Parity_PARITY_UNSPECIFIED Parity = 0
	Parity_PARITY_NONE        Parity = 1
	Parity_PARITY_ODD         Parity = 2
	Parity_PARITY_EVEN        Parity = 3
	Parity_PARITY_MARK        Parity = 4
	Parity_PARITY_SPACE       Parity = 5
)

// Enum value maps for Parity.
var (
	Parity_name = map[int32]string{
		0: "PARITY_UNSPECIFIED",
		1: "PARITY_NONE",
		2: "PARITY_ODD",
		3: "PARITY_EVEN",
		4: "PARITY_MARK",
		5: "PARITY_SPACE",
	}
	Parity_value = map[string]int32{
		"PARITY_UNSPECIFIED": 0,
		"PARITY_NONE":        1,
		"PARITY_ODD":         2,
		"PARITY_EVEN":        3,
		"PARITY_MARK":        4,
		"PARITY_SPACE":       5,
	}
)

func (x Parity) Enum() *Parity {
	p := new(Parity)
	*p = x
	return p
}

func (x Parity) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Parity) Descriptor() protoreflect.EnumDescriptor {
	return file_serial_proto_enumTypes[3].Descriptor()
}

func (Parity) Type() protoreflect.EnumType {
	return &file_serial_proto_enumTypes[3]
}

func (x Parity) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Parity.Descriptor instead.
func (Parity) EnumDescriptor() ([]byte, []int) {
	return file_serial_proto_rawDescGZIP(), []int{3}
}

type FlowControl int32

const (
	FlowControl_FLOW_CONTROL_UNSPECIFIED FlowControl = 0
	FlowControl_FLOW_CONTROL_NONE        FlowControl = 1
	FlowControl_FLOW_CONTROL_HARDWARE    FlowControl = 2 // RTS/CTS
	FlowControl_FLOW_CONTROL_SOFTWARE    FlowControl = 3 // XON/XOFF
)

// Enum value maps for FlowControl.
var (
	FlowControl_name = map[int32]string{
		0: "FLOW_CONTROL_UNSPECIFIED",
		1: "FLOW_CONTROL_NONE",
		2: "FLOW_CONTROL_HARDWARE",
		3: "FLOW_CONTROL_SOFTWARE",
	}
	FlowControl_value = map[string]int32{
		"FLOW_CONTROL_UNSPECIFIED": 0,
		"FLOW_CONTROL_NONE":        1,
		"FLOW_CONTROL_HARDWARE":    2,
		"FLOW_CONTROL_SOFTWARE":    3,
	}
)

func (x FlowControl) Enum() *FlowControl {
	p := new(FlowControl)
	*p = x
	return p
}

func (x FlowControl) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (FlowControl) Descriptor() protoreflect.EnumDescriptor {
	return file_serial_proto_enumTypes[4].Descriptor()
}

func (FlowControl) Type() protoreflect.EnumType {
	return &file_serial_proto_enumTypes[4]
}

func (x FlowControl) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use FlowControl.Descriptor instead.
func (FlowControl) EnumDescriptor() ([]byte, []int) {
	return file_serial_proto_rawDescGZIP(), []int{4}
}

type ListPortsRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Optional filter to include only available (unopened) ports
	OnlyAvailable bool `protobuf:"varint,1,opt,name=only_available,json=onlyAvailable,proto3" json:"only_available,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListPortsRequest) Reset() {
	*x = ListPortsRequest{}
	mi := &file_serial_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListPortsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListPortsRequest) ProtoMessage() {}

func (x *ListPortsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_serial_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListPortsRequest.ProtoReflect.Descriptor instead.
func (*ListPortsRequest) Descriptor() ([]byte, []int) {
	return file_serial_proto_rawDescGZIP(), []int{0}
}

func (x *ListPortsRequest) GetOnlyAvailable() bool {
	if x != nil {
		return x.OnlyAvailable
	}
	return false
}

type ListPortsResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Ports         []*PortInfo            `protobuf:"bytes,1,rep,name=ports,proto3" json:"ports,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListPortsResponse) Reset() {
	*x = ListPortsResponse{}
	mi := &file_serial_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListPortsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListPortsResponse) ProtoMessage() {}

func (x *ListPortsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_serial_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListPortsResponse.ProtoReflect.Descriptor instead.
func (*ListPortsResponse) Descriptor() ([]byte, []int) {
	return file_serial_proto_rawDescGZIP(), []int{1}
}

func (x *ListPortsResponse) GetPorts() []*PortInfo {
	if x != nil {
		return x.Ports
	}
	return nil
}

type GetPortInfoRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	PortName      string                 `protobuf:"bytes,1,opt,name=port_name,json=portName,proto3" json:"port_name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetPortInfoRequest) Reset() {
	*x = GetPortInfoRequest{}
	mi := &file_serial_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetPortInfoRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetPortInfoRequest) ProtoMessage() {}

func (x *GetPortInfoRequest) ProtoReflect() protoreflect.Message {
	mi := &file_serial_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetPortInfoRequest.ProtoReflect.Descriptor instead.
func (*GetPortInfoRequest) Descriptor() ([]byte, []int) {
	return file_serial_proto_rawDescGZIP(), []int{2}
}

func (x *GetPortInfoRequest) GetPortName() string {
	if x != nil {
		return x.PortName
	}
	return ""
}

type PortInfo struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Name          string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`                                                           // e.g., "COM3" or "/dev/ttyUSB0"
	Description   string                 `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`                                             // Human-readable description
	HardwareId    string                 `protobuf:"bytes,3,opt,name=hardware_id,json=hardwareId,proto3" json:"hardware_id,omitempty"`                             // USB VID:PID or similar
	Manufacturer  string                 `protobuf:"bytes,4,opt,name=manufacturer,proto3" json:"manufacturer,omitempty"`                                           // Device manufacturer
	Product       string                 `protobuf:"bytes,5,opt,name=product,proto3" json:"product,omitempty"`                                                     // Product name
	SerialNumber  string                 `protobuf:"bytes,6,opt,name=serial_number,json=serialNumber,proto3" json:"serial_number,omitempty"`                       // Device serial number
	PortType      PortType               `protobuf:"varint,7,opt,name=port_type,json=portType,proto3,enum=baudlink.serial.v1.PortType" json:"port_type,omitempty"` // Type of port
	IsOpen        bool                   `protobuf:"varint,8,opt,name=is_open,json=isOpen,proto3" json:"is_open,omitempty"`                                        // Whether port is currently open
	LockedBy      string                 `protobuf:"bytes,9,opt,name=locked_by,json=lockedBy,proto3" json:"locked_by,omitempty"`                                   // Client ID if locked
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PortInfo) Reset() {
	*x = PortInfo{}
	mi := &file_serial_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PortInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PortInfo) ProtoMessage() {}

func (x *PortInfo) ProtoReflect() protoreflect.Message {
	mi := &file_serial_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PortInfo.ProtoReflect.Descriptor instead.
func (*PortInfo) Descriptor() ([]byte, []int) {
	return file_serial_proto_rawDescGZIP(), []int{3}
}

func (x *PortInfo) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *PortInfo) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *PortInfo) GetHardwareId() string {
	if x != nil {
		return x.HardwareId
	}
	return ""
}

func (x *PortInfo) GetManufacturer() string {
	if x != nil {
		return x.Manufacturer
	}
	return ""
}

func (x *PortInfo) GetProduct() string {
	if x != nil {
		return x.Product
	}
	return ""
}

func (x *PortInfo) GetSerialNumber() string {
	if x != nil {
		return x.SerialNumber
	}
	return ""
}

func (x *PortInfo) GetPortType() PortType {
	if x != nil {
		return x.PortType
	}
	return PortType_PORT_TYPE_UNSPECIFIED
}

func (x *PortInfo) GetIsOpen() bool {
	if x != nil {
		return x.IsOpen
	}
	return false
}

func (x *PortInfo) GetLockedBy() string {
	if x != nil {
		return x.LockedBy
	}
	return ""
}

type OpenPortRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	PortName      string                 `protobuf:"bytes,1,opt,name=port_name,json=portName,proto3" json:"port_name,omitempty"`
	Config        *PortConfig            `protobuf:"bytes,2,opt,name=config,proto3" json:"config,omitempty"`
	ClientId      string                 `protobuf:"bytes,3,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"` // Unique client identifier for locking
	Exclusive     bool                   `protobuf:"varint,4,opt,name=exclusive,proto3" json:"exclusive,omitempty"`              // Request exclusive access
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OpenPortRequest) Reset() {
	*x = OpenPortRequest{}
	mi := &file_serial_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OpenPortRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OpenPortRequest) ProtoMessage() {}

func (x *OpenPortRequest) ProtoReflect() protoreflect.Message {
	mi := &file_serial_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OpenPortRequest.ProtoReflect.Descriptor instead.
func (*OpenPortRequest) Descriptor() ([]byte, []int) {
	return file_serial_proto_rawDescGZIP(), []int{4}
}

func (x *OpenPortRequest) GetPortName() string {
	if x != nil {
		return x.PortName
	}
	return ""
}

func (x *OpenPortRequest) GetConfig() *PortConfig {
	if x != nil {
		return x.Config
	}
	return nil
}

func (x *OpenPortRequest) GetClientId() string {
	if x != nil {
		return x.ClientId
	}
	return ""
}

func (x *OpenPortRequest) GetExclusive() bool {
	if x != nil {
		return x.Exclusive
	}
	return false
}

type OpenPortResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Message       string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	SessionId     string                 `protobuf:"bytes,3,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"` // Session ID for this connection
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OpenPortResponse) Reset() {
	*x = OpenPortResponse{}
	mi := &file_serial_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OpenPortResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OpenPortResponse) ProtoMessage() {}

func (x *OpenPortResponse) ProtoReflect() protoreflect.Message {
	mi := &file_serial_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OpenPortResponse.ProtoReflect.Descriptor instead.
func (*OpenPortResponse) Descriptor() ([]byte, []int) {
	return file_serial_proto_rawDescGZIP(), []int{5}
}

func (x *OpenPortResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *OpenPortResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *OpenPortResponse) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

type ClosePortRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	PortName      string                 `protobuf:"bytes,1,opt,name=port_name,json=portName,proto3" json:"port_name,omitempty"`
	SessionId     string                 `protobuf:"bytes,2,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ClosePortRequest) Reset() {
	*x = ClosePortRequest{}
	mi := &file_serial_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClosePortRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClosePortRequest) ProtoMessage() {}

func (x *ClosePortRequest) ProtoReflect() protoreflect.Message {
	mi := &file_serial_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClosePortRequest.ProtoReflect.Descriptor instead.
func (*ClosePortRequest) Descriptor() ([]byte, []int) {
	return file_serial_proto_rawDescGZIP(), []int{6}
}

func (x *ClosePortRequest) GetPortName() string {
	if x != nil {
		return x.PortName
	}
	return ""
}

func (x *ClosePortRequest) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

type ClosePortResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Message       string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ClosePortResponse) Reset() {
	*x = ClosePortResponse{}
	mi := &file_serial_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClosePortResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClosePortResponse) ProtoMessage() {}

func (x *ClosePortResponse) ProtoReflect() protoreflect.Message {
	mi := &file_serial_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClosePortResponse.ProtoReflect.Descriptor instead.
func (*ClosePortResponse) Descriptor() ([]byte, []int) {
	return file_serial_proto_rawDescGZIP(), []int{7}
}

func (x *ClosePortResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *ClosePortResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

type GetPortStatusRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	PortName      string                 `protobuf:"bytes,1,opt,name=port_name,json=portName,proto3" json:"port_name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetPortStatusRequest) Reset() {
	*x = GetPortStatusRequest{}
	mi := &file_serial_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetPortStatusRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetPortStatusRequest) ProtoMessage() {}

func (x *GetPortStatusRequest) ProtoReflect() protoreflect.Message {
	mi := &file_serial_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetPortStatusRequest.ProtoReflect.Descriptor instead.
func (*GetPortStatusRequest) Descriptor() ([]byte, []int) {
	return file_serial_proto_rawDescGZIP(), []int{8}
}

func (x *GetPortStatusRequest) GetPortName() string {
	if x != nil {
		return x.PortName
	}
	return ""
}

type PortStatus struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	PortName      string                 `protobuf:"bytes,1,opt,name=port_name,json=portName,proto3" json:"port_name,omitempty"`
	IsOpen        bool                   `protobuf:"varint,2,opt,name=is_open,json=isOpen,proto3" json:"is_open,omitempty"`
	IsLocked      bool                   `protobuf:"varint,3,opt,name=is_locked,json=isLocked,proto3" json:"is_locked,omitempty"`
	LockedBy      string                 `protobuf:"bytes,4,opt,name=locked_by,json=lockedBy,proto3" json:"locked_by,omitempty"`
	SessionId     string                 `protobuf:"bytes,5,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	CurrentConfig *PortConfig            `protobuf:"bytes,6,opt,name=current_config,json=currentConfig,proto3" json:"current_config,omitempty"`
	Statistics    *PortStatistics        `protobuf:"bytes,7,opt,name=statistics,proto3" json:"statistics,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PortStatus) Reset() {
	*x = PortStatus{}
	mi := &file_serial_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PortStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PortStatus) ProtoMessage() {}

func (x *PortStatus) ProtoReflect() protoreflect.Message {
	mi := &file_serial_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PortStatus.ProtoReflect.Descriptor instead.
func (*PortStatus) Descriptor() ([]byte, []int) {
	return file_serial_proto_rawDescGZIP(), []int{9}
}

func (x *PortStatus) GetPortName() string {
	if x != nil {
		return x.PortName
	}
	return ""
}

func (x *PortStatus) GetIsOpen() bool {
	if x != nil {
		return x.IsOpen
	}
	return false
}

func (x *PortStatus) GetIsLocked() bool {
	if x != nil {
		return x.IsLocked
	}
	return false
}

func (x *PortStatus) GetLockedBy() string {
	if x != nil {
		return x.LockedBy
	}
	return ""
}

func (x *PortStatus) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

func (x *PortStatus) GetCurrentConfig() *PortConfig {
	if x != nil {
		return x.CurrentConfig
	}
	return nil
}

func (x *PortStatus) GetStatistics() *PortStatistics {
	if x != nil {
		return x.Statistics
	}
	return nil
}

type PortStatistics struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	BytesSent     uint64                 `protobuf:"varint,1,opt,name=bytes_sent,json=bytesSent,proto3" json:"bytes_sent,omitempty"`
	BytesReceived uint64                 `protobuf:"varint,2,opt,name=bytes_received,json=bytesReceived,proto3" json:"bytes_received,omitempty"`
	Errors        uint64                 `protobuf:"varint,3,opt,name=errors,proto3" json:"errors,omitempty"`
	OpenedAt      int64                  `protobuf:"varint,4,opt,name=opened_at,json=openedAt,proto3" json:"opened_at,omitempty"`             // Unix timestamp
	LastActivity  int64                  `protobuf:"varint,5,opt,name=last_activity,json=lastActivity,proto3" json:"last_activity,omitempty"` // Unix timestamp
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PortStatistics) Reset() {
	*x = PortStatistics{}
	mi := &file_serial_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PortStatistics) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PortStatistics) ProtoMessage() {}

func (x *PortStatistics) ProtoReflect() protoreflect.Message {
	mi := &file_serial_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PortStatistics.ProtoReflect.Descriptor instead.
func (*PortStatistics) Descriptor() ([]byte, []int) {
	return file_serial_proto_rawDescGZIP(), []int{10}
}

func (x *PortStatistics) GetBytesSent() uint64 {
	if x != nil {
		return x.BytesSent
	}
	return 0
}

func (x *PortStatistics) GetBytesReceived() uint64 {
	if x != nil {
		return x.BytesReceived
	}
	return 0
}

func (x *PortStatistics) GetErrors() uint64 {
	if x != nil {
		return x.Errors
	}
	return 0
}

func (x *PortStatistics) GetOpenedAt() int64 {
	if x != nil {
		return x.OpenedAt
	}
	return 0
}

func (x *PortStatistics) GetLastActivity() int64 {
	if x != nil {
		return x.LastActivity
	}
	return 0
}

type PortConfig struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	BaudRate       uint32                 `protobuf:"varint,1,opt,name=baud_rate,json=baudRate,proto3" json:"baud_rate,omitempty"` // e.g., 9600, 115200
	DataBits       DataBits               `protobuf:"varint,2,opt,name=data_bits,json=dataBits,proto3,enum=baudlink.serial.v1.DataBits" json:"data_bits,omitempty"`
	StopBits       StopBits               `protobuf:"varint,3,opt,name=stop_bits,json=stopBits,proto3,enum=baudlink.serial.v1.StopBits" json:"stop_bits,omitempty"`
	Parity         Parity                 `protobuf:"varint,4,opt,name=parity,proto3,enum=baudlink.serial.v1.Parity" json:"parity,omitempty"`
	FlowControl    FlowControl            `protobuf:"varint,5,opt,name=flow_control,json=flowControl,proto3,enum=baudlink.serial.v1.FlowControl" json:"flow_control,omitempty"`
	ReadTimeoutMs  uint32                 `protobuf:"varint,6,opt,name=read_timeout_ms,json=readTimeoutMs,proto3" json:"read_timeout_ms,omitempty"`    // Read timeout in milliseconds
	WriteTimeoutMs uint32                 `protobuf:"varint,7,opt,name=write_timeout_ms,json=writeTimeoutMs,proto3" json:"write_timeout_ms,omitempty"` // Write timeout in milliseconds
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *PortConfig) Reset() {
	*x = PortConfig{}
	mi := &file_serial_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PortConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PortConfig) ProtoMessage() {}

func (x *PortConfig) ProtoReflect() protoreflect.Message {
	mi := &file_serial_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PortConfig.ProtoReflect.Descriptor instead.
func (*PortConfig) Descriptor() ([]byte, []int) {
	return file_serial_proto_rawDescGZIP(), []int{11}
}

func (x *PortConfig) GetBaudRate() uint32 {
	if x != nil {
		return x.BaudRate
	}
	return 0
}

func (x *PortConfig) GetDataBits() DataBits {
	if x != nil {
		return x.DataBits
	}
	return DataBits_DATA_BITS_UNSPECIFIED
}

func (x *PortConfig) GetStopBits() StopBits {
	if x != nil {
		return x.StopBits
	}
	return StopBits_STOP_BITS_UNSPECIFIED
}

func (x *PortConfig) GetParity() Parity {
	if x != nil {
		return x.Parity
	}
	return Parity_PARITY_UNSPECIFIED
}

func (x *PortConfig) GetFlowControl() FlowControl {
	if x != nil {
		return x.FlowControl
	}
	return FlowControl_FLOW_CONTROL_UNSPECIFIED
}

func (x *PortConfig) GetReadTimeoutMs() uint32 {
	if x != nil {
		return x.ReadTimeoutMs
	}
	return 0
}

func (x *PortConfig) GetWriteTimeoutMs() uint32 {
	if x != nil {
		return x.WriteTimeoutMs
	}
	return 0
}

type ConfigurePortRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	PortName      string                 `protobuf:"bytes,1,opt,name=port_name,json=portName,proto3" json:"port_name,omitempty"`
	SessionId     string                 `protobuf:"bytes,2,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	Config        *PortConfig            `protobuf:"bytes,3,opt,name=config,proto3" json:"config,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ConfigurePortRequest) Reset() {
	*x = ConfigurePortRequest{}
	mi := &file_serial_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConfigurePortRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConfigurePortRequest) ProtoMessage() {}

func (x *ConfigurePortRequest) ProtoReflect() protoreflect.Message {
	mi := &file_serial_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConfigurePortRequest.ProtoReflect.Descriptor instead.
func (*ConfigurePortRequest) Descriptor() ([]byte, []int) {
	return file_serial_proto_rawDescGZIP(), []int{12}
}

func (x *ConfigurePortRequest) GetPortName() string {
	if x != nil {
		return x.PortName
	}
	return ""
}

func (x *ConfigurePortRequest) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

func (x *ConfigurePortRequest) GetConfig() *PortConfig {
	if x != nil {
		return x.Config
	}
	return nil
}

type ConfigurePortResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Message       string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ConfigurePortResponse) Reset() {
	*x = ConfigurePortResponse{}
	mi := &file_serial_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConfigurePortResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConfigurePortResponse) ProtoMessage() {}

func (x *ConfigurePortResponse) ProtoReflect() protoreflect.Message {
	mi := &file_serial_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConfigurePortResponse.ProtoReflect.Descriptor instead.
func (*ConfigurePortResponse) Descriptor() ([]byte, []int) {
	return file_serial_proto_rawDescGZIP(), []int{13}
}

func (x *ConfigurePortResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *ConfigurePortResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

type GetPortConfigRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	PortName      string                 `protobuf:"bytes,1,opt,name=port_name,json=portName,proto3" json:"port_name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetPortConfigRequest) Reset() {
	*x = GetPortConfigRequest{}
	mi := &file_serial_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetPortConfigRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetPortConfigRequest) ProtoMessage() {}

func (x *GetPortConfigRequest) ProtoReflect() protoreflect.Message {
	mi := &file_serial_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetPortConfigRequest.ProtoReflect.Descriptor instead.
func (*GetPortConfigRequest) Descriptor() ([]byte, []int) {
	return file_serial_proto_rawDescGZIP(), []int{14}
}

func (x *GetPortConfigRequest) GetPortName() string {
	if x != nil {
		return x.PortName
	}
	return ""
}

type WriteRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	PortName      string                 `protobuf:"bytes,1,opt,name=port_name,json=portName,proto3" json:"port_name,omitempty"`
	SessionId     string                 `protobuf:"bytes,2,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	Data          []byte                 `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	Flush         bool                   `protobuf:"varint,4,opt,name=flush,proto3" json:"flush,omitempty"` // Flush buffer after write
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WriteRequest) Reset() {
	*x = WriteRequest{}
	mi := &file_serial_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WriteRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WriteRequest) ProtoMessage() {}

func (x *WriteRequest) ProtoReflect() protoreflect.Message {
	mi := &file_serial_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WriteRequest.ProtoReflect.Descriptor instead.
func (*WriteRequest) Descriptor() ([]byte, []int) {
	return file_serial_proto_rawDescGZIP(), []int{15}
}

func (x *WriteRequest) GetPortName() string {
	if x != nil {
		return x.PortName
	}
	return ""
}

func (x *WriteRequest) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

func (x *WriteRequest) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

func (x *WriteRequest) GetFlush() bool {
	if x != nil {
		return x.Flush
	}
	return false
}

type WriteResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	BytesWritten  uint32                 `protobuf:"varint,2,opt,name=bytes_written,json=bytesWritten,proto3" json:"bytes_written,omitempty"`
	Message       string                 `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WriteResponse) Reset() {
	*x = WriteResponse{}
	mi := &file_serial_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WriteResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WriteResponse) ProtoMessage() {}

func (x *WriteResponse) ProtoReflect() protoreflect.Message {
	mi := &file_serial_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WriteResponse.ProtoReflect.Descriptor instead.
func (*WriteResponse) Descriptor() ([]byte, []int) {
	return file_serial_proto_rawDescGZIP(), []int{16}
}

func (x *WriteResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *WriteResponse) GetBytesWritten() uint32 {
	if x != nil {
		return x.BytesWritten
	}
	return 0
}

func (x *WriteResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

type ReadRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	PortName      string                 `protobuf:"bytes,1,opt,name=port_name,json=portName,proto3" json:"port_name,omitempty"`
	SessionId     string                 `protobuf:"bytes,2,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	MaxBytes      uint32                 `protobuf:"varint,3,opt,name=max_bytes,json=maxBytes,proto3" json:"max_bytes,omitempty"`    // Maximum bytes to read
	TimeoutMs     uint32                 `protobuf:"varint,4,opt,name=timeout_ms,json=timeoutMs,proto3" json:"timeout_ms,omitempty"` // Timeout for this read operation
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReadRequest) Reset() {
	*x = ReadRequest{}
	mi := &file_serial_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReadRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReadRequest) ProtoMessage() {}

func (x *ReadRequest) ProtoReflect() protoreflect.Message {
	mi := &file_serial_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReadRequest.ProtoReflect.Descriptor instead.
func (*ReadRequest) Descriptor() ([]byte, []int) {
	return file_serial_proto_rawDescGZIP(), []int{17}
}

func (x *ReadRequest) GetPortName() string {
	if x != nil {
		return x.PortName
	}
	return ""
}

func (x *ReadRequest) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

func (x *ReadRequest) GetMaxBytes() uint32 {
	if x != nil {
		return x.MaxBytes
	}
	return 0
}

func (x *ReadRequest) GetTimeoutMs() uint32 {
	if x != nil {
		return x.TimeoutMs
	}
	return 0
}

type ReadResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Data          []byte                 `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	BytesRead     uint32                 `protobuf:"varint,3,opt,name=bytes_read,json=bytesRead,proto3" json:"bytes_read,omitempty"`
	Message       string                 `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReadResponse) Reset() {
	*x = ReadResponse{}
	mi := &file_serial_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReadResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReadResponse) ProtoMessage() {}

func (x *ReadResponse) ProtoReflect() protoreflect.Message {
	mi := &file_serial_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReadResponse.ProtoReflect.Descriptor instead.
func (*ReadResponse) Descriptor() ([]byte, []int) {
	return file_serial_proto_rawDescGZIP(), []int{18}
}

func (x *ReadResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *ReadResponse) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

func (x *ReadResponse) GetBytesRead() uint32 {
	if x != nil {
		return x.BytesRead
	}
	return 0
}

func (x *ReadResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

type StreamReadRequest struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	PortName          string                 `protobuf:"bytes,1,opt,name=port_name,json=portName,proto3" json:"port_name,omitempty"`
	SessionId         string                 `protobuf:"bytes,2,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	ChunkSize         uint32                 `protobuf:"varint,3,opt,name=chunk_size,json=chunkSize,proto3" json:"chunk_size,omitempty"`                         // Preferred chunk size
	IncludeTimestamps bool                   `protobuf:"varint,4,opt,name=include_timestamps,json=includeTimestamps,proto3" json:"include_timestamps,omitempty"` // Include timestamps in chunks
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *StreamReadRequest) Reset() {
	*x = StreamReadRequest{}
	mi := &file_serial_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamReadRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamReadRequest) ProtoMessage() {}

func (x *StreamReadRequest) ProtoReflect() protoreflect.Message {
	mi := &file_serial_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamReadRequest.ProtoReflect.Descriptor instead.
func (*StreamReadRequest) Descriptor() ([]byte, []int) {
	return file_serial_proto_rawDescGZIP(), []int{19}
}

func (x *StreamReadRequest) GetPortName() string {
	if x != nil {
		return x.PortName
	}
	return ""
}

func (x *StreamReadRequest) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

func (x *StreamReadRequest) GetChunkSize() uint32 {
	if x != nil {
		return x.ChunkSize
	}
	return 0
}

func (x *StreamReadRequest) GetIncludeTimestamps() bool {
	if x != nil {
		return x.IncludeTimestamps
	}
	return false
}

type DataChunk struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	PortName      string                 `protobuf:"bytes,1,opt,name=port_name,json=portName,proto3" json:"port_name,omitempty"`
	Data          []byte                 `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	Timestamp     int64                  `protobuf:"varint,3,opt,name=timestamp,proto3" json:"timestamp,omitempty"` // Unix timestamp in nanoseconds
	Sequence      uint32                 `protobuf:"varint,4,opt,name=sequence,proto3" json:"sequence,omitempty"`   // Sequence number for ordering
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DataChunk) Reset() {
	*x = DataChunk{}
	mi := &file_serial_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DataChunk) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DataChunk) ProtoMessage() {}

func (x *DataChunk) ProtoReflect() protoreflect.Message {
	mi := &file_serial_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DataChunk.ProtoReflect.Descriptor instead.
func (*DataChunk) Descriptor() ([]byte, []int) {
	return file_serial_proto_rawDescGZIP(), []int{20}
}

func (x *DataChunk) GetPortName() string {
	if x != nil {
		return x.PortName
	}
	return ""
}

func (x *DataChunk) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

func (x *DataChunk) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *DataChunk) GetSequence() uint32 {
	if x != nil {
		return x.Sequence
	}
	return 0
}

type StreamWriteResponse struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	Success           bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	TotalBytesWritten uint64                 `protobuf:"varint,2,opt,name=total_bytes_written,json=totalBytesWritten,proto3" json:"total_bytes_written,omitempty"`
	ChunksProcessed   uint32                 `protobuf:"varint,3,opt,name=chunks_processed,json=chunksProcessed,proto3" json:"chunks_processed,omitempty"`
	Message           string                 `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *StreamWriteResponse) Reset() {
	*x = StreamWriteResponse{}
	mi := &file_serial_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamWriteResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamWriteResponse) ProtoMessage() {}

func (x *StreamWriteResponse) ProtoReflect() protoreflect.Message {
	mi := &file_serial_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamWriteResponse.ProtoReflect.Descriptor instead.
func (*StreamWriteResponse) Descriptor() ([]byte, []int) {
	return file_serial_proto_rawDescGZIP(), []int{21}
}

func (x *StreamWriteResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *StreamWriteResponse) GetTotalBytesWritten() uint64 {
	if x != nil {
		return x.TotalBytesWritten
	}
	return 0
}

func (x *StreamWriteResponse) GetChunksProcessed() uint32 {
	if x != nil {
		return x.ChunksProcessed
	}
	return 0
}

func (x *StreamWriteResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

type PingRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Message       string                 `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PingRequest) Reset() {
	*x = PingRequest{}
	mi := &file_serial_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PingRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PingRequest) ProtoMessage() {}

func (x *PingRequest) ProtoReflect() protoreflect.Message {
	mi := &file_serial_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PingRequest.ProtoReflect.Descriptor instead.
func (*PingRequest) Descriptor() ([]byte, []int) {
	return file_serial_proto_rawDescGZIP(), []int{22}
}

func (x *PingRequest) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

type PingResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Message       string                 `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
	ServerTime    int64                  `protobuf:"varint,2,opt,name=server_time,json=serverTime,proto3" json:"server_time,omitempty"` // Unix timestamp
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PingResponse) Reset() {
	*x = PingResponse{}
	mi := &file_serial_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PingResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PingResponse) ProtoMessage() {}

func (x *PingResponse) ProtoReflect() protoreflect.Message {
	mi := &file_serial_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PingResponse.ProtoReflect.Descriptor instead.
func (*PingResponse) Descriptor() ([]byte, []int) {
	return file_serial_proto_rawDescGZIP(), []int{23}
}

func (x *PingResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *PingResponse) GetServerTime() int64 {
	if x != nil {
		return x.ServerTime
	}
	return 0
}

type GetAgentInfoRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetAgentInfoRequest) Reset() {
	*x = GetAgentInfoRequest{}
	mi := &file_serial_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetAgentInfoRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetAgentInfoRequest) ProtoMessage() {}

func (x *GetAgentInfoRequest) ProtoReflect() protoreflect.Message {
	mi := &file_serial_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetAgentInfoRequest.ProtoReflect.Descriptor instead.
func (*GetAgentInfoRequest) Descriptor() ([]byte, []int) {
	return file_serial_proto_rawDescGZIP(), []int{24}
}

type AgentInfo struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	Version           string                 `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	BuildCommit       string                 `protobuf:"bytes,2,opt,name=build_commit,json=buildCommit,proto3" json:"build_commit,omitempty"`
	BuildDate         string                 `protobuf:"bytes,3,opt,name=build_date,json=buildDate,proto3" json:"build_date,omitempty"`
	Os                string                 `protobuf:"bytes,4,opt,name=os,proto3" json:"os,omitempty"`
	Arch              string                 `protobuf:"bytes,5,opt,name=arch,proto3" json:"arch,omitempty"`
	UptimeSeconds     int64                  `protobuf:"varint,6,opt,name=uptime_seconds,json=uptimeSeconds,proto3" json:"uptime_seconds,omitempty"`
	SupportedFeatures []string               `protobuf:"bytes,7,rep,name=supported_features,json=supportedFeatures,proto3" json:"supported_features,omitempty"`
	Config            *AgentConfig           `protobuf:"bytes,8,opt,name=config,proto3" json:"config,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *AgentInfo) Reset() {
	*x = AgentInfo{}
	mi := &file_serial_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AgentInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AgentInfo) ProtoMessage() {}

func (x *AgentInfo) ProtoReflect() protoreflect.Message {
	mi := &file_serial_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AgentInfo.ProtoReflect.Descriptor instead.
func (*AgentInfo) Descriptor() ([]byte, []int) {
	return file_serial_proto_rawDescGZIP(), []int{25}
}

func (x *AgentInfo) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *AgentInfo) GetBuildCommit() string {
	if x != nil {
		return x.BuildCommit
	}
	return ""
}

func (x *AgentInfo) GetBuildDate() string {
	if x != nil {
		return x.BuildDate
	}
	return ""
}

func (x *AgentInfo) GetOs() string {
	if x != nil {
		return x.Os
	}
	return ""
}

func (x *AgentInfo) GetArch() string {
	if x != nil {
		return x.Arch
	}
	return ""
}

func (x *AgentInfo) GetUptimeSeconds() int64 {
	if x != nil {
		return x.UptimeSeconds
	}
	return 0
}

func (x *AgentInfo) GetSupportedFeatures() []string {
	if x != nil {
		return x.SupportedFeatures
	}
	return nil
}

func (x *AgentInfo) GetConfig() *AgentConfig {
	if x != nil {
		return x.Config
	}
	return nil
}

type AgentConfig struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	GrpcAddress    string                 `protobuf:"bytes,1,opt,name=grpc_address,json=grpcAddress,proto3" json:"grpc_address,omitempty"`
	TlsEnabled     bool                   `protobuf:"varint,2,opt,name=tls_enabled,json=tlsEnabled,proto3" json:"tls_enabled,omitempty"`
	MaxConnections uint32                 `protobuf:"varint,3,opt,name=max_connections,json=maxConnections,proto3" json:"max_connections,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *AgentConfig) Reset() {
	*x = AgentConfig{}
	mi := &file_serial_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AgentConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AgentConfig) ProtoMessage() {}

func (x *AgentConfig) ProtoReflect() protoreflect.Message {
	mi := &file_serial_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AgentConfig.ProtoReflect.Descriptor instead.
func (*AgentConfig) Descriptor() ([]byte, []int) {
	return file_serial_proto_rawDescGZIP(), []int{26}
}

func (x *AgentConfig) GetGrpcAddress() string {
	if x != nil {
		return x.GrpcAddress
	}
	return ""
}

func (x *AgentConfig) GetTlsEnabled() bool {
	if x != nil {
		return x.TlsEnabled
	}
	return false
}

func (x *AgentConfig) GetMaxConnections() uint32 {
	if x != nil {
		return x.MaxConnections
	}
	return 0
}

var File_serial_proto protoreflect.FileDescriptor

const file_serial_proto_rawDesc = "" +
	"\n" +
	"\fserial.proto\x12\x12baudlink.serial.v1\"9\n" +
	"\x10ListPortsRequest\x12%\n" +
	"\x0eonly_available\x18\x01 \x01(\bR\ronlyAvailable\"G\n" +
	"\x11ListPortsResponse\x122\n" +
	"\x05ports\x18\x01 \x03(\v2\x1c.baudlink.serial.v1.PortInfoR\x05ports\"1\n" +
	"\x12GetPortInfoRequest\x12\x1b\n" +
	"\tport_name\x18\x01 \x01(\tR\bportName\"\xb5\x02\n" +
	"\bPortInfo\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12 \n" +
	"\vdescription\x18\x02 \x01(\tR\vdescription\x12\x1f\n" +
	"\vhardware_id\x18\x03 \x01(\tR\n" +
	"hardwareId\x12\"\n" +
	"\fmanufacturer\x18\x04 \x01(\tR\fmanufacturer\x12\x18\n" +
	"\aproduct\x18\x05 \x01(\tR\aproduct\x12#\n" +
	"\rserial_number\x18\x06 \x01(\tR\fserialNumber\x129\n" +
	"\tport_type\x18\a \x01(\x0e2\x1c.baudlink.serial.v1.PortTypeR\bportType\x12\x17\n" +
	"\ais_open\x18\b \x01(\bR\x06isOpen\x12\x1b\n" +
	"\tlocked_by\x18\t \x01(\tR\blockedBy\"\xa1\x01\n" +
	"\x0fOpenPortRequest\x12\x1b\n" +
	"\tport_name\x18\x01 \x01(\tR\bportName\x126\n" +
	"\x06config\x18\x02 \x01(\v2\x1e.baudlink.serial.v1.PortConfigR\x06config\x12\x1b\n" +
	"\tclient_id\x18\x03 \x01(\tR\bclientId\x12\x1c\n" +
	"\texclusive\x18\x04 \x01(\bR\texclusive\"e\n" +
	"\x10OpenPortResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\x12\x1d\n" +
	"\n" +
	"session_id\x18\x03 \x01(\tR\tsessionId\"N\n" +
	"\x10ClosePortRequest\x12\x1b\n" +
	"\tport_name\x18\x01 \x01(\tR\bportName\x12\x1d\n" +
	"\n" +
	"session_id\x18\x02 \x01(\tR\tsessionId\"G\n" +
	"\x11ClosePortResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\"3\n" +
	"\x14GetPortStatusRequest\x12\x1b\n" +
	"\tport_name\x18\x01 \x01(\tR\bportName\"\xa6\x02\n" +
	"\n" +
	"PortStatus\x12\x1b\n" +
	"\tport_name\x18\x01 \x01(\tR\bportName\x12\x17\n" +
	"\ais_open\x18\x02 \x01(\bR\x06isOpen\x12\x1b\n" +
	"\tis_locked\x18\x03 \x01(\bR\bisLocked\x12\x1b\n" +
	"\tlocked_by\x18\x04 \x01(\tR\blockedBy\x12\x1d\n" +
	"\n" +
	"session_id\x18\x05 \x01(\tR\tsessionId\x12E\n" +
	"\x0ecurrent_config\x18\x06 \x01(\v2\x1e.baudlink.serial.v1.PortConfigR\rcurrentConfig\x12B\n" +
	"\n" +
	"statistics\x18\a \x01(\v2\".baudlink.serial.v1.PortStatisticsR\n" +
	"statistics\"\xb0\x01\n" +
	"\x0ePortStatistics\x12\x1d\n" +
	"\n" +
	"bytes_sent\x18\x01 \x01(\x04R\tbytesSent\x12%\n" +
	"\x0ebytes_received\x18\x02 \x01(\x04R\rbytesReceived\x12\x16\n" +
	"\x06errors\x18\x03 \x01(\x04R\x06errors\x12\x1b\n" +
	"\topened_at\x18\x04 \x01(\x03R\bopenedAt\x12#\n" +
	"\rlast_activity\x18\x05 \x01(\x03R\flastActivity\"\xe9\x02\n" +
	"\n" +
	"PortConfig\x12\x1b\n" +
	"\tbaud_rate\x18\x01 \x01(\rR\bbaudRate\x129\n" +
	"\tdata_bits\x18\x02 \x01(\x0e2\x1c.baudlink.serial.v1.DataBitsR\bdataBits\x129\n" +
	"\tstop_bits\x18\x03 \x01(\x0e2\x1c.baudlink.serial.v1.StopBitsR\bstopBits\x122\n" +
	"\x06parity\x18\x04 \x01(\x0e2\x1a.baudlink.serial.v1.ParityR\x06parity\x12B\n" +
	"\fflow_control\x18\x05 \x01(\x0e2\x1f.baudlink.serial.v1.FlowControlR\vflowControl\x12&\n" +
	"\x0fread_timeout_ms\x18\x06 \x01(\rR\rreadTimeoutMs\x12(\n" +
	"\x10write_timeout_ms\x18\a \x01(\rR\x0ewriteTimeoutMs\"\x8a\x01\n" +
	"\x14ConfigurePortRequest\x12\x1b\n" +
	"\tport_name\x18\x01 \x01(\tR\bportName\x12\x1d\n" +
	"\n" +
	"session_id\x18\x02 \x01(\tR\tsessionId\x126\n" +
	"\x06config\x18\x03 \x01(\v2\x1e.baudlink.serial.v1.PortConfigR\x06config\"K\n" +
	"\x15ConfigurePortResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\"3\n" +
	"\x14GetPortConfigRequest\x12\x1b\n" +
	"\tport_name\x18\x01 \x01(\tR\bportName\"t\n" +
	"\fWriteRequest\x12\x1b\n" +
	"\tport_name\x18\x01 \x01(\tR\bportName\x12\x1d\n" +
	"\n" +
	"session_id\x18\x02 \x01(\tR\tsessionId\x12\x12\n" +
	"\x04data\x18\x03 \x01(\fR\x04data\x12\x14\n" +
	"\x05flush\x18\x04 \x01(\bR\x05flush\"h\n" +
	"\rWriteResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12#\n" +
	"\rbytes_written\x18\x02 \x01(\rR\fbytesWritten\x12\x18\n" +
	"\amessage\x18\x03 \x01(\tR\amessage\"\x85\x01\n" +
	"\vReadRequest\x12\x1b\n" +
	"\tport_name\x18\x01 \x01(\tR\bportName\x12\x1d\n" +
	"\n" +
	"session_id\x18\x02 \x01(\tR\tsessionId\x12\x1b\n" +
	"\tmax_bytes\x18\x03 \x01(\rR\bmaxBytes\x12\x1d\n" +
	"\n" +
	"timeout_ms\x18\x04 \x01(\rR\ttimeoutMs\"u\n" +
	"\fReadResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x12\n" +
	"\x04data\x18\x02 \x01(\fR\x04data\x12\x1d\n" +
	"\n" +
	"bytes_read\x18\x03 \x01(\rR\tbytesRead\x12\x18\n" +
	"\amessage\x18\x04 \x01(\tR\amessage\"\x9d\x01\n" +
	"\x11StreamReadRequest\x12\x1b\n" +
	"\tport_name\x18\x01 \x01(\tR\bportName\x12\x1d\n" +
	"\n" +
	"session_id\x18\x02 \x01(\tR\tsessionId\x12\x1d\n" +
	"\n" +
	"chunk_size\x18\x03 \x01(\rR\tchunkSize\x12-\n" +
	"\x12include_timestamps\x18\x04 \x01(\bR\x11includeTimestamps\"v\n" +
	"\tDataChunk\x12\x1b\n" +
	"\tport_name\x18\x01 \x01(\tR\bportName\x12\x12\n" +
	"\x04data\x18\x02 \x01(\fR\x04data\x12\x1c\n" +
	"\ttimestamp\x18\x03 \x01(\x03R\ttimestamp\x12\x1a\n" +
	"\bsequence\x18\x04 \x01(\rR\bsequence\"\xa4\x01\n" +
	"\x13StreamWriteResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12.\n" +
	"\x13total_bytes_written\x18\x02 \x01(\x04R\x11totalBytesWritten\x12)\n" +
	"\x10chunks_processed\x18\x03 \x01(\rR\x0fchunksProcessed\x12\x18\n" +
	"\amessage\x18\x04 \x01(\tR\amessage\"'\n" +
	"\vPingRequest\x12\x18\n" +
	"\amessage\x18\x01 \x01(\tR\amessage\"I\n" +
	"\fPingResponse\x12\x18\n" +
	"\amessage\x18\x01 \x01(\tR\amessage\x12\x1f\n" +
	"\vserver_time\x18\x02 \x01(\x03R\n" +
	"serverTime\"\x15\n" +
	"\x13GetAgentInfoRequest\"\x9a\x02\n" +
	"\tAgentInfo\x12\x18\n" +
	"\aversion\x18\x01 \x01(\tR\aversion\x12!\n" +
	"\fbuild_commit\x18\x02 \x01(\tR\vbuildCommit\x12\x1d\n" +
	"\n" +
	"build_date\x18\x03 \x01(\tR\tbuildDate\x12\x0e\n" +
	"\x02os\x18\x04 \x01(\tR\x02os\x12\x12\n" +
	"\x04arch\x18\x05 \x01(\tR\x04arch\x12%\n" +
	"\x0euptime_seconds\x18\x06 \x01(\x03R\ruptimeSeconds\x12-\n" +
	"\x12supported_features\x18\a \x03(\tR\x11supportedFeatures\x127\n" +
	"\x06config\x18\b \x01(\v2\x1f.baudlink.serial.v1.AgentConfigR\x06config\"z\n" +
	"\vAgentConfig\x12!\n" +
	"\fgrpc_address\x18\x01 \x01(\tR\vgrpcAddress\x12\x1f\n" +
	"\vtls_enabled\x18\x02 \x01(\bR\n" +
	"tlsEnabled\x12'\n" +
	"\x0fmax_connections\x18\x03 \x01(\rR\x0emaxConnections*~\n" +
	"\bPortType\x12\x19\n" +
	"\x15PORT_TYPE_UNSPECIFIED\x10\x00\x12\x11\n" +
	"\rPORT_TYPE_USB\x10\x01\x12\x14\n" +
	"\x10PORT_TYPE_NATIVE\x10\x02\x12\x17\n" +
	"\x13PORT_TYPE_BLUETOOTH\x10\x03\x12\x15\n" +
	"\x11PORT_TYPE_VIRTUAL\x10\x04*i\n" +
	"\bDataBits\x12\x19\n" +
	"\x15DATA_BITS_UNSPECIFIED\x10\x00\x12\x0f\n" +
	"\vDATA_BITS_5\x10\x05\x12\x0f\n" +
	"\vDATA_BITS_6\x10\x06\x12\x0f\n" +
	"\vDATA_BITS_7\x10\a\x12\x0f\n" +
	"\vDATA_BITS_8\x10\b*Z\n" +
	"\bStopBits\x12\x19\n" +
	"\x15STOP_BITS_UNSPECIFIED\x10\x00\x12\x0f\n" +
	"\vSTOP_BITS_1\x10\x01\x12\x11\n" +
	"\rSTOP_BITS_1_5\x10\x02\x12\x0f\n" +
	"\vSTOP_BITS_2\x10\x03*u\n" +
	"\x06Parity\x12\x16\n" +
	"\x12PARITY_UNSPECIFIED\x10\x00\x12\x0f\n" +
	"\vPARITY_NONE\x10\x01\x12\x0e\n" +
	"\n" +
	"PARITY_ODD\x10\x02\x12\x0f\n" +
	"\vPARITY_EVEN\x10\x03\x12\x0f\n" +
	"\vPARITY_MARK\x10\x04\x12\x10\n" +
	"\fPARITY_SPACE\x10\x05*x\n" +
	"\vFlowControl\x12\x1c\n" +
	"\x18FLOW_CONTROL_UNSPECIFIED\x10\x00\x12\x15\n" +
	"\x11FLOW_CONTROL_NONE\x10\x01\x12\x19\n" +
	"\x15FLOW_CONTROL_HARDWARE\x10\x02\x12\x19\n" +
	"\x15FLOW_CONTROL_SOFTWARE\x10\x032\xcf\t\n" +
	"\rSerialService\x12X\n" +
	"\tListPorts\x12$.baudlink.serial.v1.ListPortsRequest\x1a%.baudlink.serial.v1.ListPortsResponse\x12S\n" +
	"\vGetPortInfo\x12&.baudlink.serial.v1.GetPortInfoRequest\x1a\x1c.baudlink.serial.v1.PortInfo\x12U\n" +
	"\bOpenPort\x12#.baudlink.serial.v1.OpenPortRequest\x1a$.baudlink.serial.v1.OpenPortResponse\x12X\n" +
	"\tClosePort\x12$.baudlink.serial.v1.ClosePortRequest\x1a%.baudlink.serial.v1.ClosePortResponse\x12Y\n" +
	"\rGetPortStatus\x12(.baudlink.serial.v1.GetPortStatusRequest\x1a\x1e.baudlink.serial.v1.PortStatus\x12L\n" +
	"\x05Write\x12 .baudlink.serial.v1.WriteRequest\x1a!.baudlink.serial.v1.WriteResponse\x12I\n" +
	"\x04Read\x12\x1f.baudlink.serial.v1.ReadRequest\x1a .baudlink.serial.v1.ReadResponse\x12T\n" +
	"\n" +
	"StreamRead\x12%.baudlink.serial.v1.StreamReadRequest\x1a\x1d.baudlink.serial.v1.DataChunk0\x01\x12W\n" +
	"\vStreamWrite\x12\x1d.baudlink.serial.v1.DataChunk\x1a'.baudlink.serial.v1.StreamWriteResponse(\x01\x12W\n" +
	"\x13BiDirectionalStream\x12\x1d.baudlink.serial.v1.DataChunk\x1a\x1d.baudlink.serial.v1.DataChunk(\x010\x01\x12d\n" +
	"\rConfigurePort\x12(.baudlink.serial.v1.ConfigurePortRequest\x1a).baudlink.serial.v1.ConfigurePortResponse\x12Y\n" +
	"\rGetPortConfig\x12(.baudlink.serial.v1.GetPortConfigRequest\x1a\x1e.baudlink.serial.v1.PortConfig\x12I\n" +
	"\x04Ping\x12\x1f.baudlink.serial.v1.PingRequest\x1a .baudlink.serial.v1.PingResponse\x12V\n" +
	"\fGetAgentInfo\x12'.baudlink.serial.v1.GetAgentInfoRequest\x1a\x1d.baudlink.serial.v1.AgentInfoB3Z1github.com/Shoaibashk/BaudLink/api/proto;serialpbb\x06proto3"

var (
	file_serial_proto_rawDescOnce sync.Once
	file_serial_proto_rawDescData []byte
)

func file_serial_proto_rawDescGZIP() []byte {
	file_serial_proto_rawDescOnce.Do(func() {
		file_serial_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_serial_proto_rawDesc), len(file_serial_proto_rawDesc)))
	})
	return file_serial_proto_rawDescData
}

var file_serial_proto_enumTypes = make([]protoimpl.EnumInfo, 5)
var file_serial_proto_msgTypes = make([]protoimpl.MessageInfo, 27)
var file_serial_proto_goTypes = []any{
	(PortType)(0),                 // 0: baudlink.serial.v1.PortType
	(DataBits)(0),                 // 1: baudlink.serial.v1.DataBits
	(StopBits)(0),                 // 2: baudlink.serial.v1.StopBits
	(Parity)(0),                   // 3: baudlink.serial.v1.Parity
	(FlowControl)(0),              // 4: baudlink.serial.v1.FlowControl
	(*ListPortsRequest)(nil),      // 5: baudlink.serial.v1.ListPortsRequest
	(*ListPortsResponse)(nil),     // 6: baudlink.serial.v1.ListPortsResponse
	(*GetPortInfoRequest)(nil),    // 7: baudlink.serial.v1.GetPortInfoRequest
	(*PortInfo)(nil),              // 8: baudlink.serial.v1.PortInfo
	(*OpenPortRequest)(nil),       // 9: baudlink.serial.v1.OpenPortRequest
	(*OpenPortResponse)(nil),      // 10: baudlink.serial.v1.OpenPortResponse
	(*ClosePortRequest)(nil),      // 11: baudlink.serial.v1.ClosePortRequest
	(*ClosePortResponse)(nil),     // 12: baudlink.serial.v1.ClosePortResponse
	(*GetPortStatusRequest)(nil),  // 13: baudlink.serial.v1.GetPortStatusRequest
	(*PortStatus)(nil),            // 14: baudlink.serial.v1.PortStatus
	(*PortStatistics)(nil),        // 15: baudlink.serial.v1.PortStatistics
	(*PortConfig)(nil),            // 16: baudlink.serial.v1.PortConfig
	(*ConfigurePortRequest)(nil),  // 17: baudlink.serial.v1.ConfigurePortRequest
	(*ConfigurePortResponse)(nil), // 18: baudlink.serial.v1.ConfigurePortResponse
	(*GetPortConfigRequest)(nil),  // 19: baudlink.serial.v1.GetPortConfigRequest
	(*WriteRequest)(nil),          // 20: baudlink.serial.v1.WriteRequest
	(*WriteResponse)(nil),         // 21: baudlink.serial.v1.WriteResponse
	(*ReadRequest)(nil),           // 22: baudlink.serial.v1.ReadRequest
	(*ReadResponse)(nil),          // 23: baudlink.serial.v1.ReadResponse
	(*StreamReadRequest)(nil),     // 24: baudlink.serial.v1.StreamReadRequest
	(*DataChunk)(nil),             // 25: baudlink.serial.v1.DataChunk
	(*StreamWriteResponse)(nil),   // 26: baudlink.serial.v1.StreamWriteResponse
	(*PingRequest)(nil),           // 27: baudlink.serial.v1.PingRequest
	(*PingResponse)(nil),          // 28: baudlink.serial.v1.PingResponse
	(*GetAgentInfoRequest)(nil),   // 29: baudlink.serial.v1.GetAgentInfoRequest
	(*AgentInfo)(nil),             // 30: baudlink.serial.v1.AgentInfo
	(*AgentConfig)(nil),           // 31: baudlink.serial.v1.AgentConfig
}
var file_serial_proto_depIdxs = []int32{
	8,  // 0: baudlink.serial.v1.ListPortsResponse.ports:type_name -> baudlink.serial.v1.PortInfo
	0,  // 1: baudlink.serial.v1.PortInfo.port_type:type_name -> baudlink.serial.v1.PortType
	16, // 2: baudlink.serial.v1.OpenPortRequest.config:type_name -> baudlink.serial.v1.PortConfig
	16, // 3: baudlink.serial.v1.PortStatus.current_config:type_name -> baudlink.serial.v1.PortConfig
	15, // 4: baudlink.serial.v1.PortStatus.statistics:type_name -> baudlink.serial.v1.PortStatistics
	1,  // 5: baudlink.serial.v1.PortConfig.data_bits:type_name -> baudlink.serial.v1.DataBits
	2,  // 6: baudlink.serial.v1.PortConfig.stop_bits:type_name -> baudlink.serial.v1.StopBits
	3,  // 7: baudlink.serial.v1.PortConfig.parity:type_name -> baudlink.serial.v1.Parity
	4,  // 8: baudlink.serial.v1.PortConfig.flow_control:type_name -> baudlink.serial.v1.FlowControl
	16, // 9: baudlink.serial.v1.ConfigurePortRequest.config:type_name -> baudlink.serial.v1.PortConfig
	31, // 10: baudlink.serial.v1.AgentInfo.config:type_name -> baudlink.serial.v1.AgentConfig
	5,  // 11: baudlink.serial.v1.SerialService.ListPorts:input_type -> baudlink.serial.v1.ListPortsRequest
	7,  // 12: baudlink.serial.v1.SerialService.GetPortInfo:input_type -> baudlink.serial.v1.GetPortInfoRequest
	9,  // 13: baudlink.serial.v1.SerialService.OpenPort:input_type -> baudlink.serial.v1.OpenPortRequest
	11, // 14: baudlink.serial.v1.SerialService.ClosePort:input_type -> baudlink.serial.v1.ClosePortRequest
	13, // 15: baudlink.serial.v1.SerialService.GetPortStatus:input_type -> baudlink.serial.v1.GetPortStatusRequest
	20, // 16: baudlink.serial.v1.SerialService.Write:input_type -> baudlink.serial.v1.WriteRequest
	22, // 17: baudlink.serial.v1.SerialService.Read:input_type -> baudlink.serial.v1.ReadRequest
	24, // 18: baudlink.serial.v1.SerialService.StreamRead:input_type -> baudlink.serial.v1.StreamReadRequest
	25, // 19: baudlink.serial.v1.SerialService.StreamWrite:input_type -> baudlink.serial.v1.DataChunk
	25, // 20: baudlink.serial.v1.SerialService.BiDirectionalStream:input_type -> baudlink.serial.v1.DataChunk
	17, // 21: baudlink.serial.v1.SerialService.ConfigurePort:input_type -> baudlink.serial.v1.ConfigurePortRequest
	19, // 22: baudlink.serial.v1.SerialService.GetPortConfig:input_type -> baudlink.serial.v1.GetPortConfigRequest
	27, // 23: baudlink.serial.v1.SerialService.Ping:input_type -> baudlink.serial.v1.PingRequest
	29, // 24: baudlink.serial.v1.SerialService.GetAgentInfo:input_type -> baudlink.serial.v1.GetAgentInfoRequest
	6,  // 25: baudlink.serial.v1.SerialService.ListPorts:output_type -> baudlink.serial.v1.ListPortsResponse
	8,  // 26: baudlink.serial.v1.SerialService.GetPortInfo:output_type -> baudlink.serial.v1.PortInfo
	10, // 27: baudlink.serial.v1.SerialService.OpenPort:output_type -> baudlink.serial.v1.OpenPortResponse
	12, // 28: baudlink.serial.v1.SerialService.ClosePort:output_type -> baudlink.serial.v1.ClosePortResponse
	14, // 29: baudlink.serial.v1.SerialService.GetPortStatus:output_type -> baudlink.serial.v1.PortStatus
	21, // 30: baudlink.serial.v1.SerialService.Write:output_type -> baudlink.serial.v1.WriteResponse
	23, // 31: baudlink.serial.v1.SerialService.Read:output_type -> baudlink.serial.v1.ReadResponse
	25, // 32: baudlink.serial.v1.SerialService.StreamRead:output_type -> baudlink.serial.v1.DataChunk
	26, // 33: baudlink.serial.v1.SerialService.StreamWrite:output_type -> baudlink.serial.v1.StreamWriteResponse
	25, // 34: baudlink.serial.v1.SerialService.BiDirectionalStream:output_type -> baudlink.serial.v1.DataChunk
	18, // 35: baudlink.serial.v1.SerialService.ConfigurePort:output_type -> baudlink.serial.v1.ConfigurePortResponse
	16, // 36: baudlink.serial.v1.SerialService.GetPortConfig:output_type -> baudlink.serial.v1.PortConfig
	28, // 37: baudlink.serial.v1.SerialService.Ping:output_type -> baudlink.serial.v1.PingResponse
	30, // 38: baudlink.serial.v1.SerialService.GetAgentInfo:output_type -> baudlink.serial.v1.AgentInfo
	25, // [25:39] is the sub-list for method output_type
	11, // [11:25] is the sub-list for method input_type
	11, // [11:11] is the sub-list for extension type_name
	11, // [11:11] is the sub-list for extension extendee
	0,  // [0:11] is the sub-list for field type_name
}

func init() { file_serial_proto_init() }
func file_serial_proto_init() {
	if File_serial_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_serial_proto_rawDesc), len(file_serial_proto_rawDesc)),
			NumEnums:      5,
			NumMessages:   27,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_serial_proto_goTypes,
		DependencyIndexes: file_serial_proto_depIdxs,
		EnumInfos:         file_serial_proto_enumTypes,
		MessageInfos:      file_serial_proto_msgTypes,
	}.Build()
	File_serial_proto = out.File
	file_serial_proto_goTypes = nil
	file_serial_proto_depIdxs = nil
}
